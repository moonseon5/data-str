## 08-1 선형 리스트
### 선형 리스트 정의하기 - (1)
* 리스트(list)
  - 데이터를 순서대로 나열해 놓은 자료구조
  - 가장 단순한 구조를 가진 리스트를 선형리스트(linear list)또는 연결 리스트(linked list)라고 함
  - 각 데이터의 연결 관계를 '이야기 전달하기 게임'에 비유할 수 있음
  - 즉, 한 사람을 건너뛰어 이야기를 전달할 수 없음

### 배열로 선형 리스트 만들기
* 다음 노드 꺼내기
  - 배열의 각 요소에는 연락할 순서대로 데이터가 저장
  - 전화를 걸기 위해 필요한 '다음 노드 꺼내기'는 1만큼 큰 인덱스를 갖는 요소에 접근하면 됨

* 노드의 삽입과 삭제
  - 회원번호가 55인 회원이 새로 가입했고 이 회원의 정보를 회원번호 12,33 사이에 삽입하려면 [b]와 같이 삽입 요소 다음의 모든 요소를 하나씩 뒤로 밀어야 함
  - 삭제하는 경우도 모든 요소를 뒤로 밀거나 앞으로 당겨야 함
  - 이런 작업이 필요하기 때문에 배열로 구현한 선형 리스트는 쌓이는 데이터의 크기를 미리 알아야 함
  - 데이터의 삽입, 삭제에 따라 데이터를 모두 옮겨야 하기 때문에 효율이 좋지 않음
![선형 리스트](images/image-10.png)

## 08-2 포인터를 이용한 연결 리스트
### 포인터로 연결 리스트 만들기 - (1)
* 노드용 구조체 Node
  - 노드용 객체를, 연결 리스트에 데이터를 삽입할 때 만들고 삭제할 때 없애면, 앞에서 제시한 데이터를 밀고 당기는 문제를 해결할 수 있음
  - 노드용 구조체 Node는 다음의 두 멤버, data와 next로 구성
    - data ... 데이터(Member형)
    - next ... 다음 노드에 대한 포인터(자기 자신과 같은 구조체형을 가리키는 포인터형)
  - 이와 같이 자기 자신과 같은 자료형의 객체를 가리키는 데이터가 내부에 포함
  - 이러한 자료구조를 자기 참조(self-referential)형이라고 함
  ```
  // 포인터로 만든 연결 리스트(헤더)
  #ifndef ___LinkedList
  #define ___LinkedList

  #include "Memeber.h"
  <!-- 노드 -->
  typedef struct ___node{
    Member          data;     //데이터
    struct __node * next;     //뒤쪽 포인터(다음 노드에 대한 포인터)
  } Node;

  <!-- 연결 리스트 -->
  typedef struct{
    Node *head;               //머리 노드에 대한 포인터
    Node *crnt;               //선택한 노드에 대한 포인터 
  } List;
  ```

## 08-2 포인터를 이용한 연결 리스트
### 포인터로 연결 리스트 만들기 - (3)
* 연결 리스트를 관리하는 구조체 List
  - 노드용 구조체 Node를 사용한 연결 리스트를 나타낸 것
  - List는 두 멤버로 구성되어 있고 모두 Node에 대한 포인터 자료형을 가지고 있음
  - head는 연결 리스트의 머리 노드를 가리키는 머리 포인터이고, crnt는 현재 선택한 노드를 가리키는 선택 포인터
  - '검색'한 노드를 선택하고 '삭제하는' 용도로 사용
  - 연결 리스트를 관리하는 구조체 List는 2개의 포인터만 가짐
  - ＃crnt : 현재 선택한 노드를 가리키는 포인터(커서)

## 08-3 커서를 이용한 연결 리스트
### 커서로 연결 리스트 만들기 - (1)
* 커서를 사용한 연결 리스트 - (1)
  - 프로그램 실행 중에 데이터의 개수가 크게 바뀌지 않고 데이터 개수의 최댓값을 미리 알 수 있다고 가정하면 그림 8-14처럼 배열을 사용해 효율저긍로 연결 리스틀 운용할 수 있음
  - 배열의 커서에 해당하는 값은 다음 노드에 대한 포인터가 아니라 다음 노드가 들어 있는 요소의 인덱스에 대한 값
    - 여기서 포인터 역할을 하는 인덱스를 커서(cursor)라고함

![연결 리스트](images/image-11.png)

## 08-3 커서를 이용한 연결 리스트
### 커서로 연결 리스트 만들기 - (2)
* 커서를 사용한 연결 리스트 - (2)
  - 꼬리 노드이 커서는 배열의 인덱스로는 있을 수 없는 값인 -1
  - 머리 노드를 나타내는 head도 커서이기 때문에 머리 노드 A가 들어 있는 곳인 인덱스 1이 head의 값이 됨
  - 이와 같은 방법을 사용하면 노드의 삽입, 삭제 시 요소를 옮길 필요가 없음
  - 예를 들어, 8-14의 연결 리스트의 머리에 노드 G를 삽입하면 그림 8-15와 같은 상태가 됨
  - head를 1에서 6으로 업데이트하고 노드 G의 커서에 1을 대입하면 됨
  - 이러한 점이 앞서 08-1절에서 살펴본 '배열로 선형 리스트 만들기'와의 큰 차이점

![연결 리스트2](images/image-12.png)

## 08-3 커서를 이용한 연결 리스트
### 프리 리스트 구현하기 - (1)
* 프리 리스트(free list)
  - 삭제한 레코드를 관리하기 위해 사용하는 자료구조
  - 삭제한 여러 레코드를 관리하면 앞에서 발생한 '사용하지 않는 빈 배열'의 문제를 해결할 수 있음
  - 프리 리스트는 앞에서 다룬 '커서로 연결 리스트 만들기'와 삭제한 레코드를 관리하기 위한 프리 리스트를 결합해 구현
  - 노드 구조체 Node에 추가한 멤버
    - Dnext ... 프리 리스트의 다음 포인터(프리 리스트의 다음 노드를 가리키는 다음 커서)
  - 연결 리스트를 관리하는 구조체 List에 추가한 멤버
    - deleted ... 프리 리스트의 머리 커서(프리 리스트의 머리 노드를 가리키는 커서)
    - max ... 배열의 가장 꼬리 쪽에 들어 있는 노드의 레코드 번호

## 08-4 원형 이중 연결 리스트
### 원형 리스트 알아보기 - (1)
* 원형 리스트(circular list)
  - 선형 리스트의 꼬리 노드가 머리 노드를 가리킴
  - 고리 모양으로 나열된 데이터를 저장할 때 알맞은 자료구조
  - 원형 리스트와 선형 리스트의 차이점은 꼬리 노드의 다음 노드를 가리키는 포인터가 널(NULL)이 아니라 머리 노드의 포인터값이라는 점
  - 원형 리스트는 선형 리스트에서 사용했던 것과 같은 자료형을 사용할 수 있음

## 08-4 원형 이중 연결 리스트
### 이중 연결 리스트 알아보기 - (1)
* 이중 연결 리스트(doubly linked list)
  - 선형 리스트의 가장 큰 단점은 다음 노드는 찾기 쉽지만 앞쪽의 노드를 찾으려면 비용이 든다는 점을 개선한 자료구조
  - 각 노드에는 다음 노드에 대한 포인터와 앞쪽의 노드에 대한 포인터가 주어짐

## 08-4 원형 이중 연결 리스트
### 원형 이중 연결 리스트 만들기 - (1)
* 원형 이중 연결 리스트(circular doubly linked list)
  - 앞에서 공부한 두 가지의 개념을 합함

![원형 이중 연결 리스트](images/image-13.png)